#![feature(try_trait)]

use std::error::Error;
use std::fmt;
use std::mem;
use std::ops::Try;

#[derive(Debug, Clone)]
pub struct BoxResult<T, E: ?Sized>(Result<T, Box<E>>);

impl<T, E: ?Sized> BoxResult<T, E> {
    #[allow(non_snake_case)]
    pub fn Ok(v: T) -> BoxResult<T, E> {
        BoxResult(Ok(v))
    }

    pub fn as_ref(&self) -> &Result<T, &E> {
        unsafe { mem::transmute(&self.0) }
    }

    // TODO name
    pub fn as_ref2(&self) -> Result<&T, &E> {
        match &self.0 {
            Ok(t) => Ok(t),
            Err(e) => Err(e),
        }
    }

    pub fn into_err<E2>(self) -> BoxResult<T, E2>
    where
        Box<E>: Into<Box<E2>>,
    {
        self.map_err(Into::into)
    }
}

impl<T, E: ?Sized> BoxResult<T, E> {
    pub fn map<F, U>(self, f: F) -> BoxResult<U, E>
    where
        F: FnOnce(T) -> U,
    {
        match self.0 {
            Ok(t) => BoxResult(Ok(f(t))),
            Err(e) => BoxResult(Err(e)),
        }
    }

    pub fn map_err<F, E2>(self, f: F) -> BoxResult<T, E2>
    where
        F: FnOnce(Box<E>) -> Box<E2>,
    {
        match self.0 {
            Ok(t) => BoxResult(Ok(t)),
            Err(e) => BoxResult(Err(f(e))),
        }
    }

    pub fn ok(self) -> Option<T> {
        match self.0 {
            Ok(t) => Some(t),
            Err(_) => None,
        }
    }

    pub fn err(self) -> Option<Box<E>> {
        match self.0 {
            Ok(_) => None,
            Err(e) => Some(e),
        }
    }
}

impl<T, E: ?Sized + fmt::Debug> BoxResult<T, E> {
    pub fn unwrap(self) -> T {
        self.0.unwrap()
    }
}

impl<T: fmt::Debug, E: ?Sized> BoxResult<T, E> {
    pub fn unwrap_err(self) -> Box<E> {
        self.0.unwrap_err()
    }
}

impl<T, E> BoxResult<T, E> {
    #[allow(non_snake_case)]
    pub fn Err(v: E) -> BoxResult<T, E> {
        BoxResult(Err(Box::new(v)))
    }

    pub fn unbox(self) -> Result<T, E> {
        match self.0 {
            Ok(v) => Ok(v),
            Err(b) => Err(*b),
        }
    }
}

impl<T, E> From<Result<T, E>> for BoxResult<T, E> {
    fn from(r: Result<T, E>) -> BoxResult<T, E> {
        match r {
            Ok(v) => BoxResult(Ok(v)),
            Err(v) => BoxResult(Err(Box::new(v))),
        }
    }
}

impl<T, E: ?Sized> From<Result<T, Box<E>>> for BoxResult<T, E> {
    fn from(r: Result<T, Box<E>>) -> BoxResult<T, E> {
        BoxResult(r)
    }
}

impl<T, E: ?Sized> Try for BoxResult<T, E> {
    type Ok = T;
    type Error = Box<E>;

    fn into_result(self) -> Result<T, Box<E>> {
        self.0
    }

    fn from_error(v: Box<E>) -> Self {
        BoxResult(Err(v))
    }

    fn from_ok(v: T) -> Self {
        Self::Ok(v)
    }
}

pub type DynResult<T> = BoxResult<T, dyn Error>;
pub type DynError = Box<dyn Error>;

impl<T, E: Error + 'static> From<BoxResult<T, E>> for DynResult<T> {
    fn from(r: BoxResult<T, E>) -> DynResult<T> {
        match r.0 {
            Ok(v) => BoxResult(Ok(v)),
            Err(v) => BoxResult(Err(v)),
        }
    }
}

// TODO implement downcasting
impl<T> DynResult<T> {
    /// Try to downcast to a concrete error type `E`.
    pub fn try_cast<E>(self) -> Result<BoxResult<T, E>, DynResult<T>> {
        unimplemented!();
    }

    pub fn cast<E: Downcast + Error>(self) -> BoxResult<T, E> {
        match self.0 {
            Ok(v) => BoxResult(Ok(v)),
            Err(e) => BoxResult(Err(Box::new(E::cast(e)))),
        }
    }

    /// Downcast, panics if the concrete type is not `E`.
    pub fn expect<E>(self) -> BoxResult<T, E> {
        match self.try_cast() {
            Ok(r) => r,
            Err(_) => panic!(),
        }
    }

    // For a `bail!`-like macro
    pub fn from_display<M>(message: M) -> DynResult<T>
    where
        M: fmt::Display + fmt::Debug + Send + Sync + 'static,
    {
        BoxResult(Err(Box::new(StringError(message.to_string()))))
    }
}

#[derive(Clone, Debug)]
struct StringError(String);

impl fmt::Display for StringError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Error for StringError {}

/// Indicates an error type can be downcasted infallibly.
pub trait Downcast: Sized {
    fn other(r: Box<dyn Error>) -> Self;

    fn cast(r: Box<dyn Error>) -> Self {
        unimplemented!();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use thiserror::Error;

    #[derive(Error, Debug)]
    enum TestError {
        #[error("foo")]
        Foo,
        #[error("bar: {0}")]
        Bar(String),
        #[error("other")]
        Other(DynError),
    }

    impl Downcast for TestError {
        fn other(r: Box<dyn Error>) -> TestError {
            TestError::Other(r)
        }
    }

    // Similar should be generated by #[from], which means we are not quite like thiserror (note we make Box)
    impl From<String> for Box<TestError> {
        fn from(s: String) -> Box<TestError> {
            Box::new(TestError::Bar(s))
        }
    }

    fn mtch(r: BoxResult<i32, TestError>) {
        match r.as_ref() {
            Ok(_) => {}
            Err(TestError::Foo) => {}
            _ => {}
        }
    }

    fn mtch_dyn(r: DynResult<i32>) {
        match r.expect::<TestError>().as_ref() {
            Ok(_) => {}
            Err(TestError::Foo) => {}
            _ => {}
        }
    }

    // These examples show making it easy to convert from something like tipb error
    fn bar(r: Result<i32, String>) -> BoxResult<i32, TestError> {
        let r = r?;
        BoxResult::Ok(r)
    }

    fn bar_dyn(r: Result<i32, String>) -> DynResult<i32> {
        let r = r?;
        BoxResult::Ok(r)
    }

    #[test]
    fn it_works() {
        let e = BoxResult::Err(TestError::Foo);
        mtch(e);
        let e = BoxResult::Err(TestError::Foo);
        mtch_dyn(e.into());
    }

    // TODO test combinator functions
}
